\documentclass[a4paper,12pt]{article}

\usepackage[margin=1in]{geometry} % 1-inch margins
\usepackage{tikz} % For the border
\usetikzlibrary{calc} % For coordinate calculations
\usepackage{graphicx} % For including the logo
\usepackage{lmodern} % Font package
\usepackage{titlesec} % Section formatting
\usepackage{fancyhdr} % Footer customization
\usepackage{amsmath}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{tocloft}
\usepackage[colorlinks=true, linkcolor=black, citecolor=black, urlcolor=black]{hyperref}
\usepackage{float} % precise figure placement
\usepackage{color}
\usetikzlibrary{shapes.geometric, arrows}


\titleformat{\section}
  {\normalfont\Large\bfseries\raggedright}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\raggedright}{\thesubsection}{1em}{}

\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showlines=false,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{
  style=mystyle,
  language=C
}

\begin{document}

% --- First Page Border ---
\begin{tikzpicture}[remember picture, overlay]
    \draw[line width=2pt]
        ($(current page.south west) + (0.5in, 0.5in)$)
        rectangle
        ($(current page.north east) - (0.5in, 0.5in)$);
\end{tikzpicture}


\begin{center}
    \vspace{1cm}
    {\Large \textbf{University of Science and Technology of Hanoi}}\\[0.75cm]

    
    \includegraphics[width=0.5\textwidth]{usth.png}

    \vspace{1cm}
    {\large \textbf{Distributed System}}\\[0.5cm]
    {\large \textbf{Midterm report}}\\[0.5cm]

    
    \vspace{0.8cm}
    \rule{\textwidth}{0.75pt} \\[0.3cm]
    {\huge \textbf{HTTP over MPI}}\\[0.3cm]
    \rule{\textwidth}{0.75pt} \\[1.5cm]
\end{center}


\vspace{1cm}
\noindent
\begin{tabular}{>{\bfseries}l @{\hskip 0.5cm} c @{\hskip 0.5cm} l}
    Group       & : & \textit{02}\\[0.2cm]
    Members     & : & \textit{Pham Hoang Viet - 23BI14452}\\[0.2cm]
                & : & \textit{Nghiem Xuan Son - 23BI14388}\\[0.2cm]
                & : & \textit{Vu Xuan Thai - 23BI14397}\\[0.2cm]
                & : & \textit{Hoang Minh Quan - 23BI14371}\\[0.2cm]
                & : & \textit{Nguyen Ngoc Quang - 23BI14376}\\[0.2cm]
                & : & \textit{Pham Huu Minh - 23BI14302}\\[0.2cm]
                & : & \textit{Tran Vu Cong Minh - 23BI14303}\\[0.2cm]
    Major       & : & \textit{Cyber Security}             \\[0.2cm]
    Lecturer    & : & \textit{MSc. Le Nhu Chu Hiep}\\
\end{tabular}

\vfill

% --- Footer ---
\begin{center}
    \textit{Hanoi, December 07 2025}
\end{center}

\tableofcontents
\clearpage

\section{Introduction}
This report details an MPI (Message Passing Interface)-based system designed to send an HTTP request from a client process to a server via a proxy process. The client can either send a predefined message or the contents of a file. The proxy forwards the request to a specified HTTP server, retrieves the response, and sends it back to the client. This system employs MPI for message passing, making it suitable for parallel computing environments.

\section{System Overview}
The system involves two key processes:
\begin{itemize}
    \item \textbf{Client Process}: Sends an HTTP request to the proxy, either as a predefined message or the contents of a file.
    \item \textbf{Proxy Process}: Receives the HTTP request from the client, forwards it to an HTTP server (via libcurl), and sends the response back to the client.
\end{itemize}

The communication between the client and the proxy is managed via MPI. The client sends an HTTP request message, and the proxy forwards it to the HTTP server. The proxy then returns the server's response to the client.

\section{MPI (Message Passing Interface) Overview}
\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Primitive}    & \textbf{Meaning}                                                                   \\ \hline
\texttt{MPI\_bsend}    & Append outgoing message to a local send buffer                                    \\ \hline
\texttt{MPI\_send}     & Send a message and wait until copied to local or remote buffer                    \\ \hline
\texttt{MPI\_ssend}    & Send a message and wait until receipt starts                                      \\ \hline
\texttt{MPI\_sendrecv} & Send a message and wait for reply                                                 \\ \hline
\texttt{MPI\_isend}    & Pass reference to outgoing message, and continue                                  \\ \hline
\texttt{MPI\_issend}   & Pass reference to outgoing message, and wait until receipt starts                \\ \hline
\texttt{MPI\_recv}     & Receive a message; block if there is none                                         \\ \hline
\texttt{MPI\_irecv}    & Check if there is an incoming message, but do not block                           \\ \hline
\end{tabular}
\caption{MPI Primitives and their Meanings}
\label{table:mpi_primitives}
\end{table}

MPI is a standardized and portable message-passing system designed for parallel computing. It enables processes to communicate with each other by sending and receiving messages. This system uses MPI for inter-process communication, specifically:
\begin{itemize}
    \item \textbf{MPI\_Send}: Used by the client to send the HTTP request to the proxy.
    \item \textbf{MPI\_Recv}: Used by the proxy to receive the HTTP request from the client, and by the client to receive the HTTP response from the proxy.
\end{itemize}

\subsection{Key MPI Functions Used}
\begin{itemize}
    \item \textbf{MPI\_Init}: Initializes the MPI environment.
    \item \textbf{MPI\_Comm\_rank}: Determines the rank of the process in the communicator.
    \item \textbf{MPI\_Comm\_size}: Determines the size of the communicator (number of processes).
    \item \textbf{MPI\_Send} and \textbf{MPI\_Recv}: Used for sending and receiving data.
\end{itemize}

\begin{table}[h!]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\textbf{MPI Function}  & \textbf{Purpose}                                                                                   \\ \hline
\texttt{MPI\_Init}     & Initializes the MPI environment.                                                                   \\ \hline
\texttt{MPI\_Comm\_rank} & Determines the rank (ID) of the current process within the MPI communicator.                      \\ \hline
\texttt{MPI\_Comm\_size} & Determines the total number of processes in the MPI communicator.                                 \\ \hline
\texttt{MPI\_Send}     & Sends a message (data) from one process to another.                                                \\ \hline
\texttt{MPI\_Recv}     & Receives a message (data) from another process.                                                    \\ \hline
\texttt{MPI\_Abort}    & Aborts all MPI processes in the communicator if an error occurs.                                   \\ \hline
\texttt{MPI\_Finalize} & Terminates the MPI environment, cleaning up resources used by MPI.                                 \\ \hline
\end{tabular}
\caption{Common MPI Functions and their Purposes}
\label{table:mpi_functions}
\end{table}

\section{System Architecture}

The system architecture consists of two processes:
\begin{itemize}
    \item \textbf{Client Process (Rank 0)}: Initiates the communication by sending an HTTP request to the proxy. It can either provide the message directly or specify a file to be sent.
    \item \textbf{Proxy Process (Rank 1)}: Acts as an intermediary between the client and the HTTP server. It forwards the client's request to the server and sends back the server's response to the client.
\end{itemize}

\subsection{Client Process}
\begin{itemize}
    \item \textbf{Role}: The client process is responsible for sending the HTTP request and receiving the response.
    \item \textbf{Input}: The client can either input a message manually or specify a file from which the content will be sent.
    \item \textbf{Output}: The HTTP response from the server, which is received from the proxy.
\end{itemize}

\subsection{Proxy Process}
\begin{itemize}
    \item \textbf{Role}: The proxy process receives the request from the client, forwards it to the HTTP server (using libcurl), and then sends the response back to the client.
    \item \textbf{Input}: The HTTP request from the client.
    \item \textbf{Output}: The HTTP response from the server, which is sent back to the client.
\end{itemize}

\section{Code Structure and Explanation}

\begin{lstlisting}[language=bash]
mpicc -o http_proxy_mpi http_proxy_mpi.c -lcurl
mpirun -np 2 ./http_proxy_mpi test.txt
\end{lstlisting}

\begin{lstlisting}[language=C]
#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>

#define BUFFER_SIZE 4096

size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    char *response_buffer = (char *)userp;

    if (realsize >= BUFFER_SIZE) {
        printf("Warning: Response too large, truncating...\n");
        realsize = BUFFER_SIZE - 1;
    }

    memcpy(response_buffer, contents, realsize);
    response_buffer[realsize] = 0;

    return realsize;
}

void send_http_request(const char* request, char* response) {
    CURL* curl;
    CURLcode res;

    curl = curl_easy_init();
    if (!curl) {
        fprintf(stderr, "Error initializing libcurl\n");
        strcpy(response, "Error initializing libcurl");
        return;
    }

    curl_easy_setopt(curl, CURLOPT_URL,
        "https://webhook.site/d5ea60ce-050e-47c7-b77c-bd16907f0665");
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);

    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        fprintf(stderr, "curl_easy_perform() failed: %s\n",
                curl_easy_strerror(res));
        sprintf(response, "HTTP request failed: %s",
                curl_easy_strerror(res));
    }

    curl_easy_cleanup(curl);
}

void read_file_to_buffer(const char* filename, char* buffer) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "Error opening file: %s\n", filename);
        return;
    }

    size_t bytesRead = fread(buffer, 1, BUFFER_SIZE - 1, file);
    buffer[bytesRead] = '\0';
    fclose(file);
}

int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);

    int world_rank, world_size;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    if (world_size < 2) {
        fprintf(stderr, "World size must be at least 2\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    if (world_rank == 0) {
        char http_request[BUFFER_SIZE] = {0};
        
        if (argc == 2) {
            read_file_to_buffer(argv[1], http_request);
            printf("Client is sending file content: %s\n", http_request);
        } else {
            printf("Enter a message to send:\n");
            fflush(stdout);
            fgets(http_request, BUFFER_SIZE, stdin);
            http_request[strcspn(http_request, "\n")] = 0;
        }

        MPI_Send(http_request, strlen(http_request) + 1,
                 MPI_CHAR, 1, 0, MPI_COMM_WORLD);

        char http_response[BUFFER_SIZE];
        MPI_Recv(http_response, BUFFER_SIZE, MPI_CHAR,
                 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        printf("Client received response: %s\n", http_response);

    } else if (world_rank == 1) {
        char http_request[BUFFER_SIZE];
        MPI_Recv(http_request, BUFFER_SIZE, MPI_CHAR,
                 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        printf("Proxy received request: %s\n", http_request);

        char http_response[BUFFER_SIZE] = {0};
        send_http_request(http_request, http_response);

        MPI_Send(http_response, strlen(http_response) + 1,
                 MPI_CHAR, 0, 0, MPI_COMM_WORLD);
    }

    MPI_Finalize();
    return 0;
}
\end{lstlisting}

\subsection{Header Files and Definitions}
The program includes:
\begin{itemize}
    \item \texttt{mpi.h}: MPI primitives for distributed communication.
    \item \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{string.h}: standard C I/O and utilities.
    \item \texttt{curl/curl.h}: libcurl API for HTTP requests.
\end{itemize}
\texttt{BUFFER\_SIZE} defines the maximum size of request and response buffers. A custom callback \texttt{write\_callback} is defined to safely receive HTTP response data without overflowing the buffer.

\subsection{The \texttt{write\_callback} and \texttt{send\_http\_request} Functions}
\texttt{write\_callback} is registered as the libcurl write function. It computes the size of the incoming chunk, truncates it if necessary, copies it into the response buffer, and appends a null terminator.

\texttt{send\_http\_request} initializes a CURL handle, sets the webhook URL and POST data, registers \texttt{write\_callback}, performs the HTTP request, reports errors, and cleans up.

\subsection{The \texttt{read\_file\_to\_buffer} Function}
\texttt{read\_file\_to\_buffer} opens a file, reads up to \texttt{BUFFER\_SIZE - 1} bytes, null-terminates the result, and closes the file. It is used when the client is launched with a filename as command-line argument.

\subsection{The \texttt{main} Function}
The \texttt{main} function initializes MPI, checks that at least two processes exist, and then runs the client on rank~0 and the proxy on rank~1.

\section{Flow of Execution}

\subsection{Client Process (Rank 0)}
\begin{itemize}
    \item If a filename is given (\texttt{argc == 2}), the client loads the file content into \texttt{http\_request}; otherwise it prompts the user to enter a message and flushes \texttt{stdout} so the prompt is visible immediately.
    \item The client sends the request to rank~1 with \texttt{MPI\_Send}.
    \item The client waits for the response from rank~1 with \texttt{MPI\_Recv} and prints it.
\end{itemize}

\subsection{Proxy Process (Rank 1)}
\begin{itemize}
    \item The proxy receives the request from rank~0.
    \item It calls \texttt{send\_http\_request}, which forwards the payload to the configured webhook URL and stores the HTTP response in \texttt{http\_response}.
    \item The proxy sends the response back to the client via \texttt{MPI\_Send}.
\end{itemize}

\section{Error Handling}
Error handling occurs at several levels:
\begin{itemize}
    \item If \texttt{world\_size < 2}, the program prints an error and calls \texttt{MPI\_Abort}.
    \item If a file cannot be opened in \texttt{read\_file\_to\_buffer}, an error message is printed to \texttt{stderr}.
    \item If libcurl cannot be initialized, \texttt{send\_http\_request} writes a descriptive error into the response buffer.
    \item If \texttt{curl\_easy\_perform} fails, the libcurl error string is printed and also written into the response buffer as \texttt{"HTTP request failed: ..."}.
    \item \texttt{write\_callback} guards against buffer overflow by truncating excessively large responses.
\end{itemize}

\section{Performance Considerations}
The system uses two MPI processes and fixed-size buffers, so MPI overhead is minimal and memory management is straightforward. The dominant performance factor is the HTTP round-trip time to the webhook server. The additional safety checks in \texttt{write\_callback} add negligible overhead compared with network latency.

\section{Conclusion}
This project implements an HTTP-over-MPI proxy using C, MPI, and libcurl. Rank~0 behaves as a client that can send either file contents or user-typed messages, while rank~1 acts as a proxy that forwards the request to an external HTTP service and relays the response. The design illustrates basic MPI communication, integration with a network API, and safe handling of variable-length responses.

\section{References}
\begin{itemize}
    \item \href{https://github.com/mpitutorial/mpitutorial/tree/gh-pages/tutorials/}{https://github.com/mpitutorial/mpitutorial/tree/gh-pages/tutorials/}
    \item \href{https://mpitutorial.com/tutorials/}{https://mpitutorial.com/tutorials/}
    \item \href{https://curc.readthedocs.io/en/latest/programming/MPI-C.html}{https://curc.readthedocs.io/en/latest/programming/MPI-C.html}
\end{itemize}

\end{document}
