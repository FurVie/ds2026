\documentclass[a4paper,12pt]{article}

\usepackage[margin=1in]{geometry} % 1-inch margins
\usepackage{tikz} % For the border
\usetikzlibrary{calc} % For coordinate calculations
\usepackage{graphicx} % For including images
\usepackage{lmodern} % Font package
\usepackage{titlesec} % Section formatting
\usepackage{fancyhdr} % Footer customization
\usepackage{amsmath}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{tocloft}
\usepackage[colorlinks=true, linkcolor=black, citecolor=black, urlcolor=black]{hyperref}
\usepackage{float} % precise figure placement
\usepackage{color}
\usetikzlibrary{shapes.geometric, arrows}

% --- Section Formatting ---
\titleformat{\section}
  {\normalfont\Large\bfseries\raggedright}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\raggedright}{\thesubsection}{1em}{}

% --- Code Listing Style ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showlines=false,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

% --- First Page Border ---
\begin{tikzpicture}[remember picture, overlay]
    \draw[line width=2pt]
        ($(current page.south west) + (0.5in, 0.5in)$)
        rectangle
        ($(current page.north east) - (0.5in, 0.5in)$);
\end{tikzpicture}

% --- Title Page ---
\begin{center}
    \vspace{1cm}
    {\Large \textbf{University of Science and Technology of Hanoi}}\\[0.75cm]

    \includegraphics[width=0.5\textwidth]{usth.png}

    \vspace{1cm}
    {\large \textbf{Distributed System}}\\[0.5cm]
    {\large \textbf{Midterm report}}\\[0.5cm]
    
    \vspace{0.8cm}
    \rule{\textwidth}{0.75pt} \\[0.3cm]
    {\huge \textbf{HTTP over MPI}}\\[0.3cm]
    \rule{\textwidth}{0.75pt} \\[1.5cm]
\end{center}

\vspace{1cm}
\noindent
\begin{tabular}{>{\bfseries}l @{\hskip 0.5cm} c @{\hskip 0.5cm} l}
    Group       & : & \textit{02}\\[0.2cm]
    Members     & : & \textit{Pham Hoang Viet - 23BI14452}\\[0.2cm]
                & : & \textit{Nghiem Xuan Son - 23BI14388}\\[0.2cm]
                & : & \textit{Vu Xuan Thai - 23BI14397}\\[0.2cm]
                & : & \textit{Hoang Minh Quan - 23BI14371}\\[0.2cm]
                & : & \textit{Nguyen Ngoc Quang - 23BI14376}\\[0.2cm]
                & : & \textit{Pham Huu Minh - 23BI14302}\\[0.2cm]
                & : & \textit{Tran Vu Cong Minh - 23BI14303}\\[0.2cm]
    Major       & : & \textit{Cyber Security}             \\[0.2cm]
    Lecturer    & : & \textit{MSc. Le Nhu Chu Hiep}\\
\end{tabular}

\vfill

% --- Footer ---
\begin{center}
    \textit{Hanoi, December 07 2025}
\end{center}

\clearpage
\tableofcontents
\clearpage

% --- Content ---

\section{Introduction}
This report details an MPI (Message Passing Interface)-based system designed to send an HTTP request from a client process to a server via a proxy process. The system addresses a common scenario where a client node within an internal network (without direct internet access) needs to communicate with external web services. By utilizing a Proxy node that has internet access, the client can offload the network request via MPI messages.

\section{System Architecture}

The system architecture consists of two main processes communicating within a local system, with one process acting as a gateway to the external internet.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{system architecture.png} 
    \caption{System Architecture Diagram: Client sends MPI message to Proxy, which forwards it as HTTP POST.}
    \label{fig:architecture}
\end{figure}

The system involves two key processes:
\begin{itemize}
    \item \textbf{Client Process (Rank 0)}: Initiates the communication. It reads user input or file content and sends it to the proxy via MPI. It does not communicate directly with the internet.
    \item \textbf{Proxy Process (Rank 1)}: Acts as an intermediary. It receives the MPI message, uses \texttt{libcurl} to POST the data to an external Webhook, and relays the server's response back to the client.
\end{itemize}

\section{MPI (Message Passing Interface) Overview}
MPI is a standardized and portable message-passing system designed for parallel computing. This system uses MPI for inter-process communication, specifically:
\begin{itemize}
    \item \textbf{MPI\_Send}: Used by the client to send the HTTP request payload to the proxy.
    \item \textbf{MPI\_Recv}: Used by the proxy to receive the payload, and by the client to receive the final HTTP response.
\end{itemize}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{MPI Function}  & \textbf{Purpose}                                                                                   \\ \hline
\texttt{MPI\_Init}     & Initializes the MPI environment. \\ \hline
\texttt{MPI\_Comm\_rank} & Determines the rank (ID) of the current process. \\ \hline
\texttt{MPI\_Send}     & Sends a message (data) from one process to another. \\ \hline
\texttt{MPI\_Recv}     & Receives a message (data) from another process. \\ \hline
\texttt{MPI\_Finalize} & Terminates the MPI environment. \\ \hline
\end{tabular}
\caption{Key MPI Functions Used}
\end{table}

\section{Code Structure and Implementation}

The implementation uses C with the MPI library for process communication and \texttt{libcurl} for HTTP requests.

\subsection{Full Source Code}
\begin{lstlisting}[language=C, caption={http\_proxy\_mpi.c}]
#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>

#define BUFFER_SIZE 4096

// --- NEW FUNCTION: Callback to safely receive data from Web Server ---
size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    char *response_buffer = (char *)userp;

    // Check to avoid buffer overflow
    if (realsize >= BUFFER_SIZE) {
        printf("Warning: Response too large, truncating...\n");
        realsize = BUFFER_SIZE - 1;
    }

    // Copy received data to response variable
    memcpy(response_buffer, contents, realsize);
    
    // Add null terminator
    response_buffer[realsize] = 0;

    return realsize;
}

void send_http_request(const char* request, char* response) {
    CURL* curl;
    CURLcode res;

    curl = curl_easy_init();
    if (!curl) {
        fprintf(stderr, "Error initializing libcurl\n");
        strcpy(response, "Error initializing libcurl");
        return;
    }

    // Configure the HTTP request
    // Note: URL from webhook.site for testing
    curl_easy_setopt(curl, CURLOPT_URL, "https://webhook.site/d5ea60ce-050e-47c7-b77c-bd16907f0665");
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request);

    // --- UPDATED LOGIC ---
    // Use write_callback instead of direct memcpy for safety
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);
    // --------------------

    // Perform the HTTP request
    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        sprintf(response, "HTTP request failed: %s", curl_easy_strerror(res));
    }

    curl_easy_cleanup(curl);
}

void read_file_to_buffer(const char* filename, char* buffer) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "Error opening file: %s\n", filename);
        return;
    }

    size_t bytesRead = fread(buffer, 1, BUFFER_SIZE - 1, file);
    buffer[bytesRead] = '\0';  // Null-terminate the string
    fclose(file);
}

int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);

    int world_rank, world_size;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    if (world_size < 2) {
        fprintf(stderr, "World size must be at least 2\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    if (world_rank == 0) {
        // --- CLIENT PROCESS ---
        char http_request[BUFFER_SIZE] = {0};
        
        if (argc == 2) {
            // Read from a file
            read_file_to_buffer(argv[1], http_request);
            printf("Client is sending file content: %s\n", http_request);
        } else {
            // Default message input
            printf("Enter a message to send: \n");
            fflush(stdout); // IMPORTANT: Flush stdout to display prompt immediately
            
            fgets(http_request, BUFFER_SIZE, stdin);
            http_request[strcspn(http_request, "\n")] = 0;  // Remove trailing newline
        }

        MPI_Send(http_request, strlen(http_request) + 1, MPI_CHAR, 1, 0, MPI_COMM_WORLD);

        // Receive HTTP response from proxy
        char http_response[BUFFER_SIZE];
        MPI_Recv(http_response, BUFFER_SIZE, MPI_CHAR, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        printf("Client received response: %s\n", http_response);

    } else if (world_rank == 1) {
        // --- PROXY PROCESS ---
        char http_request[BUFFER_SIZE];
        MPI_Recv(http_request, BUFFER_SIZE, MPI_CHAR, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        printf("Proxy received request: %s\n", http_request);

        // Forward the request to the HTTP server
        char http_response[BUFFER_SIZE] = {0};
        send_http_request(http_request, http_response);

        // Send the response back to the client
        MPI_Send(http_response, strlen(http_response) + 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);
    }

    MPI_Finalize();
    return 0;
}
\end{lstlisting}

\subsection{Implementation Visuals}

Below are the key logic blocks captured from the source code.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{rank0(client).png}
    \caption{Client Logic (Rank 0): Handling input and sending MPI message.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{rank1(proxy).png}
    \caption{Proxy Logic (Rank 1): Receiving MPI message, forwarding via HTTP, and returning response.}
\end{figure}

\section{Deployment and Usage Guideline}

\subsection{Prerequisites}
To compile and run this software, the following dependencies are required:
\begin{itemize}
    \item \textbf{GCC Compiler}: Standard C compiler.
    \item \textbf{MPI Implementation}: MPICH or OpenMPI.
    \item \textbf{libcurl}: The multiprotocol file transfer library.
\end{itemize}

\textbf{Installation on Kali Linux:}
\begin{lstlisting}[language=bash]
sudo apt update
sudo apt install build-essential mpich libcurl4-openssl-dev
\end{lstlisting}

\subsection{Compilation}
Use the MPI wrapper compiler \texttt{mpicc} and link the curl library:
\begin{lstlisting}[language=bash]
mpicc -o http_proxy_mpi http_proxy_mpi.c -lcurl
\end{lstlisting}

\subsection{Usage Manual}
The program supports two modes of operation:

\textbf{1. Interactive Mode (Default):}
Run the program without arguments. The client will prompt you to type a message.
\begin{lstlisting}[language=bash]
mpirun -np 2 ./http_proxy_mpi
# Then type your message when prompted
\end{lstlisting}

\textbf{2. File Mode:}
Run the program with a filename argument. The client will read the file content and send it.
\begin{lstlisting}[language=bash]
mpirun -np 2 ./http_proxy_mpi test.txt
\end{lstlisting}

\section{Experimental Results}
The system was tested by sending a custom message "hello world" from the client.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{result.png}
    \caption{Execution Result: The terminal shows the interaction between Client and Proxy, while the Webhook.site dashboard confirms the receipt of the POST request.}
    \label{fig:result}
\end{figure}

As shown in Figure \ref{fig:result}:
\begin{enumerate}
    \item The Client (Rank 0) prompts for input: "hello world".
    \item The Proxy (Rank 1) receives the request via MPI.
    \item The Webhook.site interface (background) logs the incoming POST request with the content "hello world".
    \item The Client receives the URL response from the Proxy, completing the cycle.
\end{enumerate}

\section{Team Contribution}

\begin{table}[h!]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\textbf{Member} & \textbf{Contribution} \\ \hline
Pham Hoang Viet & System Architect, Core Logic Implementation, Report Writing \\ \hline
Nghiem Xuan Son & Deployment Testing, MPI Configuration, Slide Making \\ \hline
Vu Xuan Thai & Core Logic Implementation, Deployment Testing, Final Editing \\ \hline
Hoang Minh Quan & MPI Configuration, Code Review, Report Writing\\ \hline
Nguyen Ngoc Quang & MPI Configuration, Slide Making, Report Fixing \\ \hline
Pham Huu Minh & Code Review, Testing , Slide Making  \\ \hline
Tran Vu Cong Minh & Code Review, Testing, Final Editing \\ \hline
\end{tabular}
\caption{Roles and Contributions of Team Members}
\end{table}

\section{Conclusion}
This project successfully demonstrates an HTTP-over-MPI proxy using C. Rank 0 behaves as a client that can send either file contents or user-typed messages, while rank 1 acts as a proxy that forwards the request to an external HTTP service. The design illustrates basic MPI communication combined with network programming, enabling internal nodes to interact with web services securely and efficiently.

\end{document}
